<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bot Command Safety Checker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 0;
      padding: 1.5rem;
      background: #050816;
      color: #f5f5f5;
    }
    h1, h2 {
      margin: 0 0 .75rem 0;
    }
    .card {
      background: #0b1020;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      margin-bottom: 1rem;
      border: 1px solid rgba(255,255,255,0.08);
    }
    label {
      display: inline-block;
      margin-bottom: .25rem;
    }
    textarea {
      width: 100%;
      min-height: 160px;
      background: #050816;
      color: #f5f5f5;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.15);
      padding: .5rem;
      font-family: ui-monospace, monospace;
      font-size: .85rem;
      white-space: pre;
    }
    button {
      margin-top: .6rem;
      padding: .45rem .9rem;
      border-radius: 4px;
      border: none;
      background: #2563eb;
      color: #f5f5f5;
      font-weight: 500;
      cursor: pointer;
    }
    button:disabled {
      opacity: .6;
      cursor: default;
    }
    .small {
      font-size: .8rem;
      opacity: .85;
    }
    .badge {
      display: inline-block;
      padding: .1rem .45rem;
      border-radius: 999px;
      font-size: .7rem;
      margin-right: .4rem;
    }
    .critical { background: #b91c1c; }
    .high { background: #ea580c; }
    .medium { background: #ca8a04; }
    .info { background: #1d4ed8; }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: .5rem;
      font-size: .85rem;
    }
    th, td {
      border-bottom: 1px solid rgba(255,255,255,0.08);
      padding: .4rem;
      vertical-align: top;
    }
    th {
      background: rgba(15,23,42,0.8);
      text-align: left;
      font-weight: 600;
    }
    code {
      font-family: ui-monospace, monospace;
      font-size: .8rem;
      background: rgba(15,23,42,0.9);
      padding: .05rem .2rem;
      border-radius: 3px;
    }
  </style>
</head>
<body>

  <div class="card">
    <h1>Bot Command Safety Checker</h1>
    <p class="small">
      Paste your <strong>StreamElements</strong> and/or <strong>Nightbot</strong> custom commands here, and this page
      will flag risky patterns where viewers might be able to hijack your bot’s moderator powers or external calls.<br>
      Everything runs <strong>locally in your browser</strong>. No commands are uploaded anywhere.
    </p>
  </div>

  <div class="card">
    <h2>Step 1 – StreamElements (optional)</h2>
    <ol class="small">
      <li>Go to <code>https://streamelements.com/YOURUSERNAME/commands/custom</code> while logged in.</li>
      <li>Switch to the view that shows your custom commands in a table.</li>
      <li>Select the whole table (from <code>Command / Permissions / Response / Cost</code> downwards) and copy it (Ctrl+A, Ctrl+C if needed).</li>
      <li>Paste it into the box below.</li>
    </ol>
    <label for="seInput">StreamElements custom commands table (tab-separated)</label>
    <textarea id="seInput" placeholder="Paste your StreamElements commands table here..."></textarea>
  </div>

  <div class="card">
    <h2>Step 2 – Nightbot (optional)</h2>
    <ol class="small">
      <li>Go to <code>https://nightbot.tv/t/YOURUSERNAME/commands</code> while logged in.</li>
      <li>Press <strong>Ctrl+A</strong> then <strong>Ctrl+C</strong> to copy the full commands list area (like the example you showed).</li>
      <li>Paste it into the box below.</li>
    </ol>
    <label for="nbInput">Nightbot commands page content (multi-line, as copied)</label>
    <textarea id="nbInput" placeholder="Paste your Nightbot commands page content here..."></textarea>
  </div>

  <div class="card">
    <h2>Analyze</h2>
    <button id="scanBtn">Scan</button>
    <div id="status" class="small" style="margin-top:.4rem;"></div>
  </div>

  <div id="resultsCard" class="card" style="display:none;">
    <h2>Results</h2>
    <div id="resultsBody"></div>
  </div>

<script>
  const scanBtn = document.getElementById('scanBtn');
  const statusEl = document.getElementById('status');
  const resultsCard = document.getElementById('resultsCard');
  const resultsBody = document.getElementById('resultsBody');

  scanBtn.addEventListener('click', () => {
    statusEl.textContent = 'Analyzing...';
    const seText = document.getElementById('seInput').value || '';
    const nbText = document.getElementById('nbInput').value || '';
    const commands = [];
    if (seText.trim()) commands.push(...parseTabbedCommands(seText, 'streamelements'));
    if (nbText.trim()) commands.push(...parseNightbotText(nbText));
    if (!commands.length) {
      statusEl.textContent = 'No commands detected. Make sure you pasted the tables/content correctly.';
      resultsCard.style.display = 'none';
      return;
    }
    const analyzed = analyzeAll(commands);
    renderResults(analyzed);
    resultsCard.style.display = 'block';
    statusEl.textContent = 'Scan complete.';
  });

  function parseTabbedCommands(text, provider) {
    const cmds = [];
    const lines = text.split(/\r?\n/);
    for (const raw of lines) {
      if (!raw.trim()) continue;
      const parts = raw.split('\t');
      if (parts.length < 3) continue;
      const first = parts[0].trim().toLowerCase();
      if (first === 'command') continue;
      if (!parts[0].trim().startsWith('!')) continue;
      cmds.push({
        provider,
        name: parts[0].trim(),
        accessLevel: parts[1].trim(),
        response: parts[2].trim()
      });
    }
    return cmds;
  }

  function parseNightbotText(text) {
    const cmds = [];
    const lines = text.split(/\r?\n/);
    let current = null;

    const isPerm = l =>
      /^(everyone|moderator|owner|regular|subscribers?|vip)/i.test(l);

    const ignore = l =>
      /^nightbot$/i.test(l) ||
      /commands are used/i.test(l) ||
      /^search commands/i.test(l) ||
      /^show\s+\d+/i.test(l) ||
      /^page\s+\d+\s+of\s+\d+/i.test(l) ||
      /^copyright/i.test(l) ||
      /terms of service/i.test(l) ||
      /privacy policy/i.test(l) ||
      /api documentation/i.test(l);

    for (const raw of lines) {
      const line = raw.trim();
      if (!line || ignore(line)) continue;

      if (line.startsWith('!')) {
        if (current && current.name && current.permission) {
          cmds.push({
            provider: 'nightbot',
            name: current.name,
            accessLevel: current.permission,
            response: current.response.trim()
          });
        }
        current = { name: line, response: '', permission: '' };
        continue;
      }

      if (current && isPerm(line)) {
        current.permission = line;
        continue;
      }

      if (current) {
        if (current.response) current.response += ' ';
        current.response += line;
      }
    }

    if (current && current.name && current.permission) {
      cmds.push({
        provider: 'nightbot',
        name: current.name,
        accessLevel: current.permission,
        response: current.response.trim()
      });
    }

    return cmds;
  }

  function analyzeAll(commands) {
    return commands.map(cmd => ({ ...cmd, issues: analyze(cmd) }));
  }

  function analyze(cmd) {
    const issues = [];
    const resp = cmd.response || '';
    const access = (cmd.accessLevel || '').toLowerCase();
    const isPublic =
      access.includes('everyone') ||
      access.includes('regular') ||
      access.includes('all');

     if (cmd.provider === 'streamelements') {
      // 1) Twitch /command injection via user-controlled first token
      if (isPublic && /^[\s]*\$\((args|1|touser|sender\.lastmessage|user\.lastmessage)/i.test(resp)) {
        issues.push({
          severity: 'Critical',
          type: 'TwitchCommandInjection',
          message: 'Response begins with user-controlled text (e.g. $(args)). A viewer could make your bot send Twitch slash commands like /emoteonly as a moderator.',
          fix: 'Add static text before the variable (e.g. "You said: $(args)") or restrict this command to mods only.'
        });
      }

      // 2) settitle/setgame with untrusted input
      if (/\$\(set(title|game)/i.test(resp) &&
          /\$\((args|1|touser|sender\.lastmessage|user\.lastmessage)/i.test(resp)) {
        issues.push({
          severity: isPublic ? 'High' : 'Medium',
          type: 'MetadataHijack',
          message: 'Untrusted viewer input flows into $(settitle) or $(setgame). Viewers may be able to change your stream title/category.',
          fix: 'Restrict this command to mods, and avoid passing raw arguments directly into $(settitle)/$(setgame).'
        });
      }

      // 3) customapi/urlfetch with user-controlled URL
      if (/\$\(customapi|\$\(urlfetch/i.test(resp) &&
          /\$\((args|1|touser)|\$\{1:/i.test(resp)) {
        issues.push({
          severity: 'High',
          type: 'ExternalRequestInjection',
          message: 'Viewers can influence URLs used in $(customapi) or $(urlfetch). This can be abused to fetch arbitrary external content.',
          fix: 'Use fixed URLs and only interpolate safely encoded, limited parameters. Do not let viewers control the full URL.'
        });
      }

      // 4) AI prompt control
      if (/\$\(ai/i.test(resp) &&
          /\$\((args|1|touser|sender\.lastmessage|user\.lastmessage)/i.test(resp)) {
        issues.push({
          severity: 'Medium',
          type: 'AIPromptControl',
          message: 'Viewers can heavily steer the AI prompt. This can leak past chat content or generate misleading messages from your bot.',
          fix: 'Keep the AI prompt mostly static and limit user input to small, clearly bounded fields (like one topic or username).'
        });
      }

      // 5) Repeat used with user input
      if (/\$\(repeat/i.test(resp) &&
          /\$\((args|1|touser|sender\.lastmessage|user\.lastmessage)/i.test(resp)) {
        issues.push({
          severity: 'Medium',
          type: 'SpamAmplifier',
          message: '$(repeat) is used with user-controlled text. This can amplify spam or repeat slash commands multiple times.',
          fix: 'Avoid repeating raw user input, or cap repetition and add static prefixes to prevent output starting with `/`.'
        });
      }
    }

    // NIGHTBOT RULES
    if (cmd.provider === 'nightbot') {
      // 1) Twitch /command injection via $(query)/$(1)/$(touser)
      if (isPublic && /^[\s]*\$\((query|querystring|[0-9]|touser)/i.test(resp)) {
        issues.push({
          severity: 'Critical',
          type: 'TwitchCommandInjection',
          message: 'Response begins with $(query)/$(1)/$(touser). A viewer could make Nightbot send Twitch slash commands as a mod.',
          fix: 'Add static text before these variables (e.g. "You said: $(query)") or restrict this command to mods only.'
        });
      }

      // 2) eval + user input
      if (/\$\(eval/i.test(resp) &&
          /\$\((query|querystring|[0-9])/i.test(resp)) {
        issues.push({
          severity: 'High',
          type: 'EvalInjection',
          message: 'User input flows into $(eval). This can lead to risky JavaScript execution in Nightbot\'s sandbox.',
          fix: 'Avoid using $(eval) on raw viewer input. If you must use eval, only operate on strictly validated, whitelisted values.'
        });
      }

      // 3) urlfetch + user input
      if (/\$\(urlfetch/i.test(resp) &&
          /\$\((query|querystring)/i.test(resp)) {
        issues.push({
          severity: 'High',
          type: 'ExternalRequestInjection',
          message: 'Viewers can control URLs fetched by $(urlfetch). This can be abused to reflect arbitrary external content into chat.',
          fix: 'Use fixed URLs with limited, encoded parameters. Do not let viewers provide the full URL in $(urlfetch).'
        });
      }
    }

    return issues;
  }

  function renderResults(commands) {
    const rows = [];
    commands.forEach(cmd => {
      if (!cmd.issues.length) return;
      cmd.issues.forEach(issue => {
        const cls = issue.severity.toLowerCase();
        rows.push(`
          <tr>
            <td>${escape(cmd.provider)}</td>
            <td><code>${escape(cmd.name)}</code></td>
            <td>${escape(cmd.accessLevel)}</td>
            <td>
              <span class="badge ${cls}">${issue.severity}</span><br>
              <span class="small">${escape(issue.type)}</span>
            </td>
            <td>
              <div class="small">${escape(issue.message)}</div>
              <div class="small" style="margin-top:.25rem;"><strong>Fix:</strong> ${escape(issue.fix)}</div>
              <div class="small" style="margin-top:.25rem;"><strong>Response:</strong> <code>${escape(shorten(cmd.response,160))}</code></div>
            </td>
          </tr>
        `);
      });
    });

    if (!rows.length) {
      resultsBody.innerHTML =
        `<p>No major risks detected.</p><p class="small">Still review commands that echo user input or call external APIs.</p>`;
      return;
    }

    resultsBody.innerHTML = `
      <table>
        <thead>
          <tr>
            <th>Provider</th>
            <th>Command</th>
            <th>Access</th>
            <th>Risk</th>
            <th>Details</th>
          </tr>
        </thead>
        <tbody>${rows.join('')}</tbody>
      </table>
    `;
  }

  function escape(str) {
    return (str || '').replace(/[&<>"'`]/g, s => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;',
      '"': '&quot;', "'": '&#39;', '`': '&#96;'
    }[s]));
  }

  function shorten(str, max) {
    return (!str || str.length <= max) ? str : str.slice(0, max) + '…';
  }
</script>

</body>
</html>
